import { Injectable } from '@angular/core';
import { Task } from '../models/task';
import { TASKS } from './mock-task';
// Injectable — це декоратор, який дозволяє Angular
// використовувати цей клас як сервіс, який можна інжектувати
// в інші компоненти або сервіси.
// Task — це клас моделі, що визначає структуру
// об'єкта завдання.
// TASKS — це масив з попередньо визначеними завданнями,
// імпортований з файлу mock-task.ts.

@Injectable({
  providedIn: 'root'
})
// Клас TaskService містить методи для роботи з масивом
// завдань.
// private tasks: Task[] = TASKS; — оголошує приватну
// властивість tasks, яка ініціалізується значенням
// з масиву TASKS.
export class TaskService {
  private tasks: Task[] = TASKS;
  constructor() { }

  // Цей метод повертає весь масив завдань.
  // Використовується для отримання всіх завдань у додатку.
  // Порожні дужки () після назви методу вказують на те,
  // що цей метод не приймає жодних аргументів.

  // (): Task[]:
  // Тип, що повертається: Task[] — це тип даних, який метод
  // повертає. Тут вказано, що метод повертає масив ([]) об'єктів
  // типу Task. У TypeScript обов'язково потрібно вказувати
  // типи для функцій і методів, щоб забезпечити строгість типізації.
  getTasks(): Task[] {
    return this.tasks;
  }
  // this.tasks — this вказує на поточний екземпляр класу
  // TaskService. tasks — це властивість цього класу, яка
  // містить масив всіх завдань. Використовуючи this.tasks,
  // ми отримуємо доступ до цього масиву.

  // Метод шукає та повертає завдання за певним id.
  // Якщо завдання не знайдено, повертається undefined.
  // id: number — метод приймає один параметр id,
  // який має бути числом (number).
  getTask(id: number): Task | undefined {
    return this.tasks.find(task => task.id === id);
  }
  // Task | undefined — цей синтаксис вказує, що метод може повернути
  // або об'єкт типу Task, або undefined.
  // Якщо завдання із заданим id знайдено, метод поверне об'єкт Task.
  // Якщо завдання не знайдено, повернеться undefined.
  // this.tasks.find(...) — метод find() шукає перший елемент в масиві
  // tasks, який задовольняє умову, передану в колбек-функцію.

  // Колбек-функція: task => task.id === id

  // Це стрілкова функція (arrow function), яка приймає один параметр task
  // (об'єкт типу Task з масиву tasks).
  // task.id === id — перевіряє, чи збігається id поточного завдання (task.id)
  // з тим id, що переданий як аргумент в метод getTask.
  // Якщо знайдено завдання із заданим id, то метод find() повертає цей об'єкт Task.

  // Додає нове завдання у масив tasks.
  // Цей метод отримує на вхід об'єкт типу Task і додає його в кінець масиву tasks.
  addTask(task: Task): void {
    this.tasks.push(task);
  }
  // Параметри методу:

  // task: Task — метод приймає один параметр task, який є об'єктом типу Task.
  // Цей об'єкт містить всю необхідну інформацію про нове завдання, яке потрібно
  // додати (наприклад, id, title, description, dueDate, priority).
  // Тип, що повертається: void означає, що цей метод не повертає жодного значення.
  // Він просто виконує дію (у цьому випадку, додає завдання до масиву).

  // this.tasks.push(task);:
  // Тіло методу:
  // this.tasks — це масив, який зберігає всі завдання в сервісі TaskService.
  // .push(task) — метод push() додає новий елемент в кінець масиву tasks.
  // У цьому випадку, до масиву додається новий об'єкт task, переданий як
  // параметр в метод addTask.
  // Використання this вказує на те, що ми працюємо з масивом tasks, який
  // є властивістю поточного екземпляра класу TaskService.

  // Оновлює існуюче завдання у масиві tasks,
  // знаходячи його за id і замінюючи його на updatedTask.
  updateTask(updatedTask: Task): void {
    const index = this.tasks.findIndex(task => task.id === updatedTask.id);
    if (index !== -1) {
      this.tasks[index] = updatedTask;
    }
  }
  // 1. updateTask(updatedTask: Task):

  // Назва методу: updateTask означає "оновити завдання".
  // Параметри методу:
  // updatedTask: Task — метод приймає один параметр updatedTask, який є об'єктом
  // типу Task. Цей об'єкт містить нові дані для завдання, яке потрібно оновити.

  // 2. : void:

  // Тип, що повертається: void означає, що цей метод не повертає жодного значення.
  // Він просто виконує дію (у цьому випадку, оновлює завдання у масиві tasks).

  // 3. const index = this.tasks.findIndex(task => task.id === updatedTask.id);:

  // Пошук індексу:
  // this.tasks — це масив, який зберігає всі завдання в сервісі TaskService.
  // .findIndex(task => task.id === updatedTask.id) — метод findIndex() проходить
  // по кожному елементу масиву tasks і повертає індекс першого елемента, для якого
  // умова task.id === updatedTask.id є істинною. Тобто, він шукає індекс завдання,
  // id якого співпадає з id оновленого завдання updatedTask.
  // Якщо таке завдання знайдене, findIndex() повертає його індекс. Якщо не знайдене,
  // повертається -1.

  // 4. if (index !== -1) { this.tasks[index] = updatedTask; }:

  // Перевірка існування завдання:
  // if (index !== -1) — ця умова перевіряє, чи було знайдено завдання у масиві. Якщо
  // index !== -1,
  // це означає, що завдання з таким id існує в масиві.
  // this.tasks[index] = updatedTask; — якщо завдання знайдено, то воно замінюється
  // на updatedTask, яке було передане в метод. Це означає, що всі дані про це
  // завдання оновлюються на нові.

  // Видаляє завдання з масиву tasks, використовуючи id.
  deleteTask(id: number): void {
    this.tasks = this.tasks.filter(task => task.id !== id);
  }
}
// 3. this.tasks = this.tasks.filter(task => task.id !== id);:

// Фільтрація масиву:
// this.tasks — це масив, який зберігає всі завдання в сервісі TaskService.
// .filter(task => task.id !== id) — метод filter() проходить по кожному
// елементу масиву tasks і повертає новий масив, який містить лише ті завдання,
// для яких умова task.id !== id є істинною. Тобто, залишаються лише ті
// завдання, id яких не співпадає з переданим параметром id.
// this.tasks = — після виконання методу filter(), результат (новий масив
// без видаленого завдання) присвоюється назад у змінну this.tasks.
